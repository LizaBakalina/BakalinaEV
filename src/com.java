import java.util.function.Predicate;

public class ILinkedListPoyasnylka implements IList { //Имплементаця интерфейса, то есть привязывает файл к нему, чтобы мы могли его использовать
    private static class Node { // создание обекта класса, то есть каждого элемента в нашем списке,
        // privet означает, что можно работать с обектом только внутри класса
        Node next; // создание поля next в котором хранится ссылка на следующий элемент в списке
        int payload; // создание поля payload в котором хранится значение этого элемента
        public Node (int payload) { // конструктор класса, который вызывается при создании обекта этого класса
            this.payload = payload; //здесь указывается, что поле payload равняется параметру payload, который мы передаем при создании элемента
            next = null; //здесь указывается, что ссылка на следующий элемент при создании по умолчанию равна null(то есть в ней ничего нет)
        }
    }
    private Node head;//создаем поле head в котором хранится первый элемент нашего списка
    int size;//создаем поле size в котором хранится размер нашего списка
    @Override// команда, которая означает, что этот метод(функция) есть в интерфейсе и мы ее используем
    public void add(int value) { //метод, который добавляет новый элемент в конец списка
        Node newNode = new Node(value); //создаем наш новый элемент, у которого значение будет равно value,
        // а ссылка будет null(пустой) это прописано в конструкторе
        if (head == null) { //проверяем пустая лм голова, то есть есть ли элементы в нашем списке или нет
            head = newNode; // если элементов нет, то мы head приравниваем нашему новому элементу, то есть теперь это первый элемент в списке
        } else { // если элементы в списке уже есть:
            Node currNode = head; //создаем обект currNode(текущий элемент) который в начале равен head, то есть первому элементу
            while (currNode.next != null) { // пока ссылка текущего элемента на следующий не равна null:
                currNode = currNode.next; //текущий элемента равен следующему,то есть шагаем так по каждому элементу, пока не дойдем до конца
            }
            currNode.next = newNode;//когда дошли до последнего элемента, мы говорим,
            //что currNode(указатель на текущий элемент, который уже остановился на соседнем) ссылается на наш новый элемент
        } //таким образом мы добавили новый элемент в конец списка
        size ++; //увиличиваем размер на единицу, т.к. добавили один элемент
    }

    @Override // команда, которая означает, что этот метод(функция) есть в интерфейсе и мы ее используем( и что она отличается от предыдущего add)
    public void add(int index, int value) {// функция, которая добавляет элемент по индексу
        Node currentNode = head; //создаем обект currNode(текущий элемент) который в начале равен head, то есть первому элементу
        if (index < 0) { //проверяем, меньше ли нуля индекс
            throw new IndexOutOfBoundsException("Некорректный индекс"); //если да, то выдаем исключение
        } else if (index == 0) { // если индекс равен 0
            Node node = new Node(value); // создаем новый элемент
            node.next = currentNode; // говорим, что теперь он ссылается на текущий, то есть на head(первый элемент
            head = node; // head приравниваем к нашему новому элементу, то есть делаем его новым первым элементов в списке
        } // если индекс > 0:
        int counter = 0; //создаем каунтер, который будет считать количество пройденных элементов
        index--; //уменьшаем индекс на 1, т.к. нам нужно вставить наш новый элемент, между текущим элементом с таким индексом и предыдущим
        //для этого мы останавливаемя на предыдущем элементе
        while (counter < index) {// пока каунтер меньше чем индекс:
            if (currentNode == null) {// если наш текущий элемент равен null, то есть пустой, а мы все еще не дошли до нужного по индексу
                // значит, что индекс больше размера списка
                throw new IndexOutOfBoundsException("Некорректный индекс");// тогда мы выдаем исключение(обходим ошибку)
            }
            currentNode = currentNode.next;//текущий элемент приравниваем к следующему, то есть шагаем на следующий
            counter++;// увеличиваем каунтер на 1
            // так мы шагаем,пока каунтер не будет равен индексу, то есть мы нашли нужный элемент,
            // либо пока не выйдем за размер списка, тогда вызывается исключение(как описано выше в if)
        }
        if (counter == index) { //если каунтер равен индексу, то есть мы нашли нудный элемент:
            Node node = new Node(value); //создаем новый обект класса Node
            node.next = currentNode.next;//говорим, что теперь он ссылается туда же, куда и ссылается текущий элемент
            currentNode.next = node;//а текущий элемент теперь ссылается на новый
        }// получается мы вставили наш новый элемент между текущим элементом, с таким индексом и предыдущим
        size ++;//увеличиваем размер списка на 1, так добавили одн новый элемент
    }

    @Override // команда, которая означает, что этот метод(функция) есть в интерфейсе и мы ее используем
    public void remove(int index) { //функция, которая удаляет элемент по индексу
        if (index < 0 || head == null) {// если индекс меньше 0 или head равен null(то есть список пустой)
            throw new IndexOutOfBoundsException("Некорректный индекс");//выдаем исключение
        }
        int counter = 0;//создаем каунтер
        Node currNode = head;//создаем обект currNode(текущий элемент) который в начале равен head, то есть первому элементу
        Node prevNode = head;//создаем обект prevNode(предыдущий элемент) который в начале равен head, то есть первому элементу
        if (index == 0) {// если индекс равен 0, то есть хотим удалить первый элемент
            head = head.next;//приравниваем head к следующему элементу, то есть head равен второму элементу
        } else {//если индекс больше 0
            while (counter != index) {// пока каунтер не равен индексу, то есть пока не дойдем до нужного элемента
                if (currNode.next == null) { //если head равен hull, то есть список пустой
                    throw new IndexOutOfBoundsException("Некорректный индекс");//выдаем исключение
                }
                prevNode = currNode;//предыдущий элемент становится равен текущему
                currNode = currNode.next;//а текущй элемент становится равен следующему
                counter++;// увеличиваем каунтер на 1
            }// таким образом проходим по каждому элементу, пока не дойдем до нужного или пока не выйдем за границы списка
            // тогда вызываем исключение как указано выше
            prevNode.next = currNode.next;//после того как нашли нужный элемент, предыдущий элемент теперь ссылается туда же, куда ссылается и текущий
            // (то есть обрываем связь, а значит удаляем элемент)
        }
        size --;//уменьшаем размер на единицу
    }

    @Override //команда, которая означает, что этот метод(функция) есть в интерфейсе и мы ее используем(и что она отличается от предыдущего remove)
    public void remove(Predicate<Integer> condition) {// удаление элемента по условию(Predicate<Integer> condition - обозначение условия)
        Node currNode = head;//текущий элемент приравниваем к head
        Node prevNode = null;//предыдущий элемент равняется null(пока он пустой)
        while (currNode != null) {//пока текущий элемент не будет пустым, то есть перебираем все элементы
            if (condition.test(currNode.payload)) {//если значение элемента(payload) проходит по условию, то:
                if (prevNode == null) {//если предыдущий элемент равен null, то есть мы хотим удалить первый элемент
                    head = head.next;//мы говорим, что head равен head.next, то есть голова это теперь второй элемент
                } else {//если предыдущий элемент не null, то есть мы хотим удалить уже не первый элемент
                    prevNode.next = currNode.next;//предыдущий элемент теперь ссылается туда же, куда ссылается и текущий
                    // (то есть обрываем связь, а значит удаляем элемент)
                }
                size --;//уменьшаем размер на 1, так как удаляем 1 элемент
            } else {//если значение элемента(payload) не проходит по условию, то:
                prevNode = currNode;//предыдущий элемент приравниваем к текущему
            }
            currNode = currNode.next;//текущий элемент приравниваем к следующему
        }
    }

    @Override //команда, которая означает, что этот метод(функция) есть в интерфейсе
    public int get(int index) {//метод, который возвращает значение элемента по индексу
        // (поэтому в начале пере get пишем int - тип возвращаемых данных
        if ((index == 0 & head != null)) {// если индекс равен 0 и head не пустой(то есть в списке есть элементы)
            return head.payload;//возвращаем значение головы
        } else if (index < size & index > 0 & head != null) {//проверяем индекс на корректность(меньше размера, больше нуля, список не пустой)
            Node currNode = head;//текущий элемент приравниваем к head
            int couter = 0;// каунтер равен 0
            while (couter < index) {//пока каунтер меньше чем индекс
                currNode = currNode.next;// текущий элемент равен следующему(шагаем по элементам)
                couter++;//увеличивает каунтер на 1
            }
            return currNode.payload;//возвращаем значене элемента
        }
        throw new IndexOutOfBoundsException("Некорректный индекс");//если не один if не выполнен, выдаем исключение
    }

    @Override //команда, которая означает, что этот метод(функция) есть(нет) в интерфейсе, но есть в классе
    public String toString() {// метод, который превращает нашу матрицу в строку
        StringBuilder list = new StringBuilder();//создаем обект класса стрингбилдер, который будет превращать матрицу в строку
        Node currNode = head;//приравниваем текущий элемент к head
        while (currNode != null) {//пока текущий элемент не равен 0
            list.append(currNode.payload);//добавляем в лист значения каждого элемента
            if (currNode.next != null) {//если это не последний элемент(то есть ссылка не равна null)
                list.append(", ");//добавляем ","
            }
            currNode = currNode.next;//текущий элемент равен следующему(шагаем дальше)
        }
        return list.toString();//возвращаем список со значениями в строковом формате
    }
}
